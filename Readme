**WaterFall Model(Software Development LifeCycle Method)**

> Requirements
    > Design 
        > Development 
            > Testing 
                > Deployment 
                    > Maintainance

--------------------------------------------------------------

**Parameter          Monolith            Microservices**
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Development Speed  Slow                Fast
Code Repo          Large and complex   Small and efficient
Scalability        Complex             Easy
Deployment         Complex             Hard
Tech Stack         Restricted          Flexible
Infra Cost         Low                 High
Complexity         High                Low
Fault Isolation    Hard                Easy
Testing            Easy                Hard
Ownership          Centralized         Distributed
Maintenance        Hard                Easy
Debugging          Easy                Hard
Dev Experience     Average             Good

--------------------------------------------------------------

What are we buiding in Dev Tinder

> Two Microservices
    1. FrontEnd: React
    2. Backend: Nodejs

Both the microservices will communicate using APIs

--------------------------------------------------------------

**DevTinder**

1. Create an account
2. Login
3. Update your profile
4. Feed page-explore
5. Send connection request
6. See due matched
7. See the request we've sent/received
8. Update your profile


--------------------------------------------------------------

**HTTP Methods**

1. POST
2. GET
3. PATCH
4. DELETE


--------------------------------------------------------------

**Advanced routing techniques**

Express 5 does not support regex.if we still try to use uh regex in express 5 it will just directly crash our app.

1. /ab?c : b is optional
    /a(bc)?d : We can group bc as well

2. /ab+c : Multiple b can be in place, such as abbbbbbbbc
    /a(bc)+d : Multiple b can be in place, such as abbbbbbbbc

3. /ab*cd : It will start with ab and anything in between and end with cd

4. RegEx /a/ : It means anywhere in path a is there it will work.
    /.*fly$/ : It will start with anything and end with fly


--------------------------------------------------------------


**Reading the query parameters**

http://localhost:3000/search?term=books&limit=10&page=2


app.get("/search", (req, res, next) => {
    const searchTerm = req.query.term
    const limit = req.query.limit
    const page = req.query.page
    res.send(`Search Term: ${searchTerm}, Limit: ${limit}, Page: ${page}`)
})

To read single parameter
http://localhost:3000/search?term=books&limit=10&page=2



**Dynamic Routes**

http://localhost:3000/user/101/mypassword

app.get("/user/:userid", (req,res) => {
    console.log(req.query)
    res.send({firstName: "Akshay", lastName: "Saini"})
})

Complex param

app.get("/user/:userid/:username:/password", (req,res) => {
    console.log(req.params)
    res.send({firstName: "Akshay", lastName: "Saini"})
})


--------------------------------------------------------------

Next Function


app.use("/user", (req, res, next) => {
    // res.send("Route handler 1")
    console.log("Handle the route user");
    res.send("Response!") 
    next()
},
    (req, res) => {
        console.log("Handle the route user 2");
        res.send("Response 2!")  
    }
)

The next function is the third argument. Once the execution comes to next() it will directly jump the execution to the next route. Once immediate next route is executed, then it will come back to the next line.

--------------------------------------------------------------

Middlewares & Error handles

> What is Middleware?

    Middleware in Express.js refers to functions that execute during the lifecycle of a request to the Express server. These functions have access to the request object (req), the response object (res), and a next function that passes control to the next middleware in the stack. Middleware functions can:

    Execute any code.
    Modify the request and response objects.
    End the request-response cycle.
    Call the next middleware function in the stack.

    Typical middleware examples include authentication checks, logging, request parsing (like body-parser), handling errors, and enabling CORS.

> Why Do We Need Middleware in Express.js?
    Middleware provides a structured and modular way to:

    Reuse common logic
    Intercept and process requests
    Maintain clean code
    Handle errors





